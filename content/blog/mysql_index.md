---
title: "MySQL的索引"
date: 2021-06-25T16:34:37+08:00
author:     "zhouyang"
draft: true
tags:
    - mysql
categories: [ MySQL ]   
---

# 数据页
是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。所以数据库读写一次最少都要16KB。

InnoDB为了不同的目的而设计了许多种不同类型的页，比如存放表空间头部信息的页，存放Insert Buffer信息的页，存放INODE信息的页，存放undo日志信息的页等等等等。

我们主要需要了解的是存放我们表中记录的页类型，官方称之为索引页，但我们我还是先称之为数据页。

## 数据页格式

![](/img/datapage.png)

|名称|中文名|占用空间大小|简单描述|
|:--:|:--:|:--:|:--|
|`File Header`|文件头部|`38`字节|页的一些通用信息|
|`Page Header`|页面头部|`56`字节|数据页专有的一些信息|
|`Infimum + Supremum`|最小记录和最大记录|`26`字节|两个虚拟的行记录|
|`User Records`|用户记录|不确定|实际存储的行记录内容|
|`Free Space`|空闲空间|不确定|页中尚未使用的空间|
|`Page Directory`|页面目录|不确定|页中的某些记录的相对位置,可以理解为为了加快在页面中的搜索速度而实现的针对该数据页记录的目录|
|`File Trailer`|文件尾部|`8`字节|校验页是否完整|


## 数据页如何存储记录

记录会被存储到`User Records`部分，但是在数据页刚被分配的时候，User Records为空，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了。

### 记录行

记录是以记录行的形式添加到 User Records 中的，下面呢我们大概来了解一下记录行的格式

![](/img/recorddata.png)

我们看到有很多我们熟悉的

- 变长字段列表
- null值列表
  - 记录允许为null的字段，是否为null，每个字段使用1bit来表示
  - 如果所有字段都不能为null，则在记录行中就没有这个部分
  - 这就是我们经常说的为什么字段设置为null会多占用空间，用1个bit来表示1个nullable字段是否为空
  - MySQL规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0，就算只有1个字段没有设置not null，那么也需要使用1字节来存储null列表
  - 另外需要注意的点是，null值列表中表示的字段顺序和后面记录中字段的顺序是相反的。
- 记录头信息
  - 这个在数据页结构很重要，下面我们单独来说
- 隐藏字段
  - 事务id 和 回滚指针。在事务和MVCC中起到重要作用
- 记录中字段值
  - 这个就是我们自己定义的字段里存储的值

### 记录头信息

|名称|大小bit|描述|
|:--:|:--:|:--:|
|`预留位1`|`1`|没有使用|
|`预留位2`|`1`|没有使用|
|`delete_mask`|`1`|标记该记录是否被删除|
|`min_rec_mask`|`1`|B+树的每层非叶子节点中的最小记录都会添加该标记(只针对索引类型记录)|
|`n_owned`|`4`|<span style="color:red">表示当前记录拥有的记录数，每个分组的最后一条记录，用来保存这个分组中有几条记录</span>|
|`heap_no`|`13`|表示当前记录在记录堆的位置信息|
|`record_type`|`3`|<span style="color:red">表示当前记录的类型，<br />`0`表示普通记录，<br />`1`表示B+树非叶节点记录，也就是索引<br />`2`表示最小记录，<br />`3`表示最大记录</span>|
|`next_record`|`16`|<span style="color:red">表示下一条记录的相对位置; 就是依靠它，一个数据页中的所有记录行，就串成了一个长长的单向链表</span>|

## Page Directory(页面目录)
上面我们了解到数据页中存储的就是一条条的记录，每个数据页一般来说有16KB大小，这样的一个数据页根据存储的表数据不同，能够存下几百到上千条记录行。上面我们了解到页中的所有的记录行是一个链表。这样的话如果我们在数据页中查询一条记录，那么就需要遍历整个数据页中的记录行链表，这样的效率十分低下，为了解决这个问题，InnoDB的设计者为每个数据页都建立了一个目录，这个目录就是Page Directory。

- 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。<span style="color:red">分组规则:</span>
  - 对于最小记录所在的分组只能有 1 条记录
  - 最大记录所在的分组拥有的记录条数只能在 1~8 条之间
  - 剩下的分组中记录的条数范围只能在是 4~8 条之间
- 每个组的最后一条记录（也就是组内主键最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
- <span style="color:red">将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方</span>，这个地方就是所谓的Page Directory，也就是页目录

![](/img/pageDirectory.png)

有个`Page Directory`之后，我们在来看一下如何查找记录

- 首先我们可以通过二分法先定位到记录所在的分组
  - 二分法，首先要求记录是有序的，先找到中间的一条记录，然后对比，如果小，则在左边继续二分，直到找到对应的记录
  - 首先`Page Directory`是有序的，并且记录了每个组中最后一条记录的偏移量，所以可以通过偏移量快速的找到组中最后一条记录。
  - 把要查找的记录和组中的最后一条记录对比，最终找到记录所在的组
- 找到对应的组后，就可以比遍历组中的记录来找对应的记录了，因为每组内记录较少，可以效率很高
  - 在遍历的时候我们需要找到组中最开始的那条记录，但是`Page Directory`中只记录了最后一条，那怎么处理呢
  - 别忘了我们所有的记录都在一个大的单向链表中。一个组的最后一条的`next record`指向的就是下一组的第一条了。


## Page Header(页面头部)

这一部分用来记录当前数据页的一些状态信息,该部分固定占用56字节，比如

- 本页中已经存储了多少条记录
- 第一条记录的地址是什么
- 页目录中存储了多少个槽
- 本页的Free Space地址
- <span style="color:red"> 第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</span>
- 本页在B+树中的层级 等等

下面是详细的描述

|名称|占用空间大小|描述|
|:--:|:--:|:--:|
|`PAGE_N_DIR_SLOTS`|`2`字节|在页目录中的槽数量|
|`PAGE_HEAP_TOP`|`2`字节|还未使用的空间最小地址，也就是说从该地址之后就是`Free Space`|
|`PAGE_N_HEAP`|`2`字节|本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）|
|`PAGE_FREE`|`2`字节|第一个已经标记为删除的记录地址（各个已删除的记录通过`next_record`也会组成一个单链表，这个单链表中的记录可以被重新利用）|
|`PAGE_GARBAGE`|`2`字节|已删除记录占用的字节数|
|`PAGE_LAST_INSERT`|`2`字节|最后插入记录的位置|
|`PAGE_DIRECTION`|`2`字节|记录插入的方向|
|`PAGE_N_DIRECTION`|`2`字节|一个方向连续插入的记录数量|
|`PAGE_N_RECS`|`2`字节|该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）|
|`PAGE_MAX_TRX_ID`|`8`字节|修改当前页的最大事务ID，该值仅在二级索引中定义|
|`PAGE_LEVEL`|`2`字节|当前页在B+树中所处的层级|
|`PAGE_INDEX_ID`|`8`字节|索引ID，表示当前页属于哪个索引|
|`PAGE_BTR_SEG_LEAF`|`10`字节|B+树叶子段的头部信息，仅在B+树的Root页定义|
|`PAGE_BTR_SEG_TOP`|`10`字节|B+树非叶子段的头部信息，仅在B+树的Root页定义|


## File Header(记录)

<span style="color:red"> Page Header是专门针对数据页记录的各种状态信息</span>，比方说页里头有多少个记录了呀，有多少个槽了呀。

<span style="color:red"> File Header针对各种类型的页都通用，</span>也就是说不同类型的页都会以File Header作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁,这个部分占用固定的38个字节，是由下边这些内容组成的：

|名称|占用空间大小|描述|
|:--:|:--:|:--:|
|`FIL_PAGE_SPACE_OR_CHKSUM`|`4`字节|页的校验和（checksum值）|
|`FIL_PAGE_OFFSET`|`4`字节|页号|
|`FIL_PAGE_PREV`|`4`字节|上一个页的页号|
|`FIL_PAGE_NEXT`|`4`字节|下一个页的页号|
|`FIL_PAGE_LSN`|`8`字节|页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）|
|`FIL_PAGE_TYPE`|`2`字节|该页的类型|
|`FIL_PAGE_FILE_FLUSH_LSN`|`8`字节|仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值|
|`FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID`|`4`字节|页属于哪个表空间|

这里我们重点关注几个属性

### FIL_PAGE_SPACE_OR_CHKSUM
表示该数据页的校验和，和MD5类似，用来校验数据页数据是否完整。

### FIL_PAGE_OFFSET

每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号来可以唯一定位一个页。

### FIL_PAGE_TYPE

这个代表当前页的类型，我们前边说过，InnoDB为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的数据页，其实还有很多别的类型的页，具体如下表：

|类型名称|十六进制|描述|
|:--:|:--:|:--:|
|`FIL_PAGE_TYPE_ALLOCATED`|0x0000|最新分配，还没使用|
|`FIL_PAGE_UNDO_LOG`|0x0002|Undo日志页|
|`FIL_PAGE_INODE`|0x0003|段信息节点|
|`FIL_PAGE_IBUF_FREE_LIST`|0x0004|Insert Buffer空闲列表|
|`FIL_PAGE_IBUF_BITMAP`|0x0005|Insert Buffer位图|
|`FIL_PAGE_TYPE_SYS`|0x0006|系统页|
|`FIL_PAGE_TYPE_TRX_SYS`|0x0007|事务系统数据|
|`FIL_PAGE_TYPE_FSP_HDR`|0x0008|表空间头部信息|
|`FIL_PAGE_TYPE_XDES`|0x0009|扩展描述页|
|`FIL_PAGE_TYPE_BLOB`|0x000A|BLOB页|
|`FIL_PAGE_INDEX`|0x45BF|索引页，也就是我们所说的`数据页`|

### FIL_PAGE_PREV和FIL_PAGE_NEXT

一个数据页的大小通常为16KB，如果数据量大，那么就需要很多个数据页来共存存储。多个数据页不可能都被分配到连续的物理内存上，所以通过这两个属性把多个数据页连接起来，形成一个双向链表。

![](/img/fileHeader.png)


## File Trailer
我们知道数据页是在硬盘和内存之间不断的被读取和写入的。一个数据页的大小为16KB，那如果在写一个数据页时，中间断电了怎么办，这时候一个数据页只被写了一半的数据。这个时候就要用到我们上面提到的 File Header中的校验和与File Trailer了。

File Trailer 大小为8字节，有两个部分组成

- 前4个字节代表页的校验和
- 后4个字节代表页面被最后修改时对应的日志序列位置

这里我们先关注校验和

- 因为FileHeader是在数据页的最上面，所以在写入的时候也是被首先写入的
- File Trailer是在数据的尾部，他的写入是最后完成的
- 在正常情况下他们两个的校验和肯定是保持一致的，但是如果发生了我们上面提到的断电的情况，一个数据页只写入了一半。我们就可以通过判断这两个校验和是否一致来判断这个数据页的写入是否完整的完成了。


## 数据页结构总结
上面写的内容是为了让大家对数据页有一个基础的了解，下面我试着总结一下

- 首先一张数据库表，可能有一个或者多个数据页来组成
- 单独的一个数据页在物理空间上是连续的，但是多个数据页就不一定是连续的了，所以这些数据页之间会通过`File Header`中的 PREV 和 NEXT 指针连接起来，成为一个双向链表
- 在每个数据页中，都能够存储多条记录行，存储在 `User Record`,每次插入新的记录行，都会从`Free Space`分配空间。
- 数据页中的所有记录行(包括最大记录和最小记录)，会通过记录行结构中记录头的`next record`连接起来，成为一个单向链表
- 为了提高在数据页中查询记录的效率，对所有的记录行进行了分组，其中最小记录单独一组，其他记录每4-8条分为一组，最大记录所在的组1-8条。
- 并把每个分组的最后一条记录的偏移量保存起来，叫做这个页的目录，也就是 `Page Directory`,通过页目录中的偏移量，可以快速的找到对应的记录，所以就能够通过二分法确定记录所在的组，然在组内遍历找到对应的记录。
- 数据页中保存了多少条记录，分了多少个组，被删除记录的链表头指针，本数据页在B+数中的层级这些信息，被保存在了`Page Header`中。
- 并且为校验数据页在写入过程中是否被中断过，在File Header(数据页头) 和 File Trailer(数据页尾)都添加了校验和，用来校验次数据页是否完整。

我觉的其中中重要的点就是

- <span style="color:red"> 多个数据页之间是双向链表 </span>
- <span style="color:red"> 数据页中的记录行是单向链表 </span>
- <span style="color:red"> 数据页中会对记录行进行分组 </span>


![](/img/dataPage1.png)

### 在单个数据页中的查找流程

下面在啰嗦一遍在<span style="color:red">一个数据页中查询记录的过程</span>

> 各个数据页可以组成一个双向链表，
>
> 而每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，
>
> 每个数据页都会为存储在它里边儿的记录生成一个页目录，
>
> 在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，
>
> 然后再遍历该槽对应分组中的记录即可快速找到指定的记录


# MySQL索引数据结构

如果说，上面就是索引的数据结构你会不会惊讶？

但结果就是这样的，索引数据同样采用和上面一样的数据页结构来存储。

在上面的数据页结构中，我们分析了在一个数据页中如何找到一条记录。

但是一张大数据量的表中可能包含成千上万个数据页，我们改如何确定这条记录在哪个数据页中呢？

- 方案一: 从第一个数据页开始遍历，因为多个数据页之间组成了链表，所以能够整个遍历一遍，那么就能找到这条记录了。显然这样的方式性能十分低下
- 方案二: 我们还记得数据页中的`Page Directory页目录`吗？，我们也可以为多个数据页建立类似的目录结构。 这样我们就能同样使用二分法来确定记录所在的数据页了。

<span style = "color:red">是的，其实这就是索引的作用，帮我们快速找到对应记录所在的数据页</span>

## InnoDB的索引方案

我们对索引的需求是，能够使用二分法快速定位到对应的数据页上，所以我们在索引的结构里需要存储

- 数据页的序号(在上面的File Header中提到过，通过它可以快速定位到数据页)
- 该数据页主键索引的最大值或者最小值
  - 这里InnoDB采用的最小值
    - <span style="color:red">这里我猜测可能的原因可能是，如果保存最大值，那么表示，每往数据页加入一条新纪录(主键自增的情况)，这个值就需要更新一次。</span>
    - <span style="color:red">如果是最小值，在主键自增的情况下，只有第一次想数据页中加入数据时需要改一次，后续往数据页中插入新的数据都不需要变化。

那么把这两个数据存在什么位置呢？
还记得我们上面说到记录行的记录头信息中有一个`record_type`字段

-  0表示普通记录
-  1表示B+树非叶节点记录
-  2表示最小记录
-  3表示最大记录

InnoDB就是采用`record_type=1`的记录行来记录索引信息

然后把数据页的序号和数据页中最小的主键值存储到记录行的列信息部分。

然后把这些索引类型的记录行，放到和上面结构一样的数据页中。

这样我们就完美是，使用同一套数据页格式，既存储了索引数据，有存储了真正的表数据。

### 索引记录和普通记录的区别

- 索引记录的record_type值是1，而普通用户记录的record_type值是0。
- 索引记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列
- 记录头中`min_rec_mask`的区别，如果该记录是索引类型记录，并且该记录是数据页中主键最小的记录，`min_rec_mask`值为1，其他情况都为0

除了上述几点外，这两者就没啥差别了，
- 它们用的是一样的数据页。
- 数据页的组成结构也是一样一样的（上面介绍的7个部分），
- 都会为数据页中的记录生成Page Directory（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。


### 索引结构B+数

我们来看一下，添加了索引数据页之后的结构

![](/img/index1.png)

 我们看到`索引数据页`中有多条记录行，每条记录行都指向一个`用户记录数据页`，并保存着指向的这个数据页的最小的主键。

数据页的大小同样都为16KB，但是存储索引记录的数据页只需要保存2个字段即可，所以一个数据页保存的索引记录的数量要大于保存普通记录的数量。

在不断向表中添加数据的情况下，肯定会出现一个索引数据页无法保存所有的索引记录，这时候就需要重新分配新的索引数据页

![](/img/index2.png)

如果我们继续想表中添加数据，就会生成更多的索引数据页。根数据页



## 为什么实用B+数

- 多叉树，可以保证树的层数比较低，减少IO的次数
  - 一般千万级别的数据的索引，使用3到4层即可
- 叶子节点有序
- 每个节点可以存储多条数据，每个节点可以存储degree -1 条数据
-

## B+树的特点


# 索引优化

- 回表
- 覆盖索引
- 最左匹配
- 索引下推

## 建立索引的注意事项

- 建立索引的字段不宜太长
  - 字段短的话，则在一个数据页中可以存储更多的索引，从而可以减少IO的次数
  - 当然业务优先
- 表的主键最好使用自增、
  - 在自增的情况下，添加新的数据，只会影响最后面的数据页。
  - 而不自增的id，会导致页分裂
  - 比如身份证表中，身份证号是唯一的，但是不适合用来当主键，因为主键是聚簇索引，如果聚簇索引的大小是随机的，会导致很多务必要的数据行移动
  - 最好添加一列额外的id当做自增主键，哪怕用不到

## 索引失效条件

## 覆盖索引

## 索引合并

## 索引下推

## explain

### 字段解释

### 如果判断实用哪个索引

### key length的计算方法

### possible key 有但是 key 没有的情况

## 索引中null的问题，null会不会被加入到索引中？

# MySQL执行过程






[MySQL中IS NULL、IS NOT NULL、!=不能用索引](https://juejin.cn/post/6844903921450745863)
