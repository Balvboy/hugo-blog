<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="date" content="2021-05-21">
<meta name="published" content="true">
<meta name="tags" content=",- volatile">
<meta name="categories" content="[ tech ]">
<meta name="description" content="&quot;volatile&quot;">
<meta name="draft" content="true">
<meta name="layout" content="post">
<meta name="showonlyimage" content="false">
<meta name="author" content="&quot;zhouyang&quot;">
<meta name="mermaid" content="true"><style>body {
  max-width: 980px;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 45px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable,
.markdown-body .highlighttable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr,
.markdown-body .highlighttable {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite,
.markdown-body .highlighttable pre,
.markdown-body .highlighttable div.highlight {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td,
.markdown-body .highlighttable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headerlink {
  font: normal 400 16px fontawesome-mini;
  vertical-align: middle;
  margin-left: -16px;
  float: left;
  display: inline-block;
  text-decoration: none;
  opacity: 0;
  color: #333;
}

.markdown-body .headerlink:focus {
  outline: none;
}

.markdown-body h1 .headerlink {
  margin-top: 0.8rem;
}

.markdown-body h2 .headerlink,
.markdown-body h3 .headerlink {
  margin-top: 0.6rem;
}

.markdown-body h4 .headerlink {
  margin-top: 0.2rem;
}

.markdown-body h5 .headerlink,
.markdown-body h6 .headerlink {
  margin-top: 0;
}

.markdown-body .headerlink:hover,
.markdown-body h1:hover .headerlink,
.markdown-body h2:hover .headerlink,
.markdown-body h3:hover .headerlink,
.markdown-body h4:hover .headerlink,
.markdown-body h5:hover .headerlink,
.markdown-body h6:hover .headerlink {
  opacity: 1;
  text-decoration: none;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite,
.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre,
.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* MultiMarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px fontawesome-mini;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\e157';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><style>/*GitHub*/
.highlight {background-color:#fff;color:#333333;}
.highlight .hll {background-color:#ffffcc;}
.highlight .c{color:#999988;font-style:italic}
.highlight .err{color:#a61717;background-color:#e3d2d2}
.highlight .k{font-weight:bold}
.highlight .o{font-weight:bold}
.highlight .cm{color:#999988;font-style:italic}
.highlight .cp{color:#999999;font-weight:bold}
.highlight .c1{color:#999988;font-style:italic}
.highlight .cs{color:#999999;font-weight:bold;font-style:italic}
.highlight .gd{color:#000000;background-color:#ffdddd}
.highlight .ge{font-style:italic}
.highlight .gr{color:#aa0000}
.highlight .gh{color:#999999}
.highlight .gi{color:#000000;background-color:#ddffdd}
.highlight .go{color:#888888}
.highlight .gp{color:#555555}
.highlight .gs{font-weight:bold}
.highlight .gu{color:#800080;font-weight:bold}
.highlight .gt{color:#aa0000}
.highlight .kc{font-weight:bold}
.highlight .kd{font-weight:bold}
.highlight .kn{font-weight:bold}
.highlight .kp{font-weight:bold}
.highlight .kr{font-weight:bold}
.highlight .kt{color:#445588;font-weight:bold}
.highlight .m{color:#009999}
.highlight .s{color:#dd1144}
.highlight .n{color:#333333}
.highlight .na{color:teal}
.highlight .nb{color:#0086b3}
.highlight .nc{color:#445588;font-weight:bold}
.highlight .no{color:teal}
.highlight .ni{color:purple}
.highlight .ne{color:#990000;font-weight:bold}
.highlight .nf{color:#990000;font-weight:bold}
.highlight .nn{color:#555555}
.highlight .nt{color:navy}
.highlight .nv{color:teal}
.highlight .ow{font-weight:bold}
.highlight .w{color:#bbbbbb}
.highlight .mf{color:#009999}
.highlight .mh{color:#009999}
.highlight .mi{color:#009999}
.highlight .mo{color:#009999}
.highlight .sb{color:#dd1144}
.highlight .sc{color:#dd1144}
.highlight .sd{color:#dd1144}
.highlight .s2{color:#dd1144}
.highlight .se{color:#dd1144}
.highlight .sh{color:#dd1144}
.highlight .si{color:#dd1144}
.highlight .sx{color:#dd1144}
.highlight .sr{color:#009926}
.highlight .s1{color:#dd1144}
.highlight .ss{color:#990073}
.highlight .bp{color:#999999}
.highlight .vc{color:teal}
.highlight .vg{color:teal}
.highlight .vi{color:teal}
.highlight .il{color:#009999}
.highlight .gc{color:#999;background-color:#EAF2F5}
</style><title>"Java同步机制(二)-Volatile"</title></head><body><article class="markdown-body"><hr />
<h1 id="volatilejava">volatile在Java中的语义<a class="headerlink" href="#volatilejava" title="Permanent link"></a></h1>
<p>对于volatile我们都比较熟悉，<code>volatile</code>在Java中有两种作用</p>
<ul>
<li>保障字段在多线程之间的可见性</li>
<li>防止指令进行重排序(编译器层面和CPU层面，后面会说明)</li>
</ul>
<p>下面我就来看一下jvm是如何实现这两种作用的</p>
<h1 id="jvmvolatile">JVM对volatile的实现<a class="headerlink" href="#jvmvolatile" title="Permanent link"></a></h1>
<p><code>volatile</code>关键字只能用来修饰属性。对于属性有获取和设置两种操作，所以我们就从这两种操作入手分析一下JVM对volitile的处理。</p>
<p>上面的两种操作在字节码中对应着 <code>getfield</code>，<code>getstatic</code>和<code>putfield</code>，<code>putfield</code>这四种字节码。</p>
<p>我们去<code>bytecodeinterpreter.cpp</code>看一下对应的实现逻辑。(说明一下，JVM现在使用的是模板编译器的，但是字节码编译器可读性比较好，用来学习还是比较合适的)</p>
<p>我们找到上面几个字节码的执行位置</p>
<div class="highlight"><pre><span class="p">...</span>
<span class="n">CASE</span><span class="p">(</span><span class="n">_getfield</span><span class="p">)</span><span class="o">:</span>
<span class="n">CASE</span><span class="p">(</span><span class="n">_getstatic</span><span class="p">)</span><span class="o">:</span>
<span class="p">{</span>
   <span class="p">...</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">is_volatile</span><span class="p">())</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">support_IRIW_for_not_multiple_copy_atomic_cpu</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">OrderAccess</span><span class="o">::</span><span class="n">fence</span><span class="p">();</span>
     <span class="p">}</span>
     <span class="p">...</span>
   <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>

<div class="highlight"><pre><span class="p">...</span>
<span class="n">CASE</span><span class="p">(</span><span class="n">_putfield</span><span class="p">)</span><span class="o">:</span>
<span class="n">CASE</span><span class="p">(</span><span class="n">_putstatic</span><span class="p">)</span><span class="o">:</span>
<span class="p">{</span>
   <span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">is_volatile</span><span class="p">())</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">OrderAccess</span><span class="o">::</span><span class="n">storeload</span><span class="p">();</span>
  <span class="p">}</span> 
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>

<p>可以看到，在访问对象字段的时候，会先判断它是不是<code>volatile</code>的，如果是的话，并且当前CPU平台支持多核核atomic操作的话（现代的绝大多数的CPU都支持），然后就调用<code>OrderAccess::fence()</code>。
在设置字段的时候，会使用<code>OrderAccess::storeload();</code>
这两个就是JVM提供的内存屏障。</p>
<h2 id="jvm">JVM提供的内存屏障<a class="headerlink" href="#jvm" title="Permanent link"></a></h2>
<p>JVM中，所有内存屏障的使用都由OrderAccess来提供。在<code>OrderAccess.hpp</code>中说明了JVM提供的几种内存屏障。</p>
<div class="highlight"><pre><span class="c1">//                Memory Access Ordering Model</span>
<span class="c1">//</span>
<span class="c1">// This interface is based on the JSR-133 Cookbook for Compiler Writers.</span>
<span class="c1">//</span>
<span class="c1">// In the following, the terms &#39;previous&#39;, &#39;subsequent&#39;, &#39;before&#39;,</span>
<span class="c1">// &#39;after&#39;, &#39;preceding&#39; and &#39;succeeding&#39; refer to program order.  The</span>
<span class="c1">// terms &#39;down&#39; and &#39;below&#39; refer to forward load or store motion</span>
<span class="c1">// relative to program order, while &#39;up&#39; and &#39;above&#39; refer to backward</span>
<span class="c1">// motion.</span>
<span class="c1">//</span>
<span class="c1">// We define four primitive memory barrier operations.</span>
<span class="c1">//</span>
<span class="c1">// LoadLoad:   Load1(s); LoadLoad; Load2</span>
<span class="c1">//</span>
<span class="c1">// Ensures that Load1 completes (obtains the value it loads from memory)</span>
<span class="c1">// before Load2 and any subsequent load operations.  Loads before Load1</span>
<span class="c1">// may *not* float below Load2 and any subsequent load operations.</span>
<span class="c1">//</span>
<span class="c1">// StoreStore: Store1(s); StoreStore; Store2</span>
<span class="c1">//</span>
<span class="c1">// Ensures that Store1 completes (the effect on memory of Store1 is made</span>
<span class="c1">// visible to other processors) before Store2 and any subsequent store</span>
<span class="c1">// operations.  Stores before Store1 may *not* float below Store2 and any</span>
<span class="c1">// subsequent store operations.</span>
<span class="c1">//</span>
<span class="c1">// LoadStore:  Load1(s); LoadStore; Store2</span>
<span class="c1">//</span>
<span class="c1">// Ensures that Load1 completes before Store2 and any subsequent store</span>
<span class="c1">// operations.  Loads before Load1 may *not* float below Store2 and any</span>
<span class="c1">// subsequent store operations.</span>
<span class="c1">//</span>
<span class="c1">// StoreLoad:  Store1(s); StoreLoad; Load2</span>
<span class="c1">//</span>
<span class="c1">// Ensures that Store1 completes before Load2 and any subsequent load</span>
<span class="c1">// operations.  Stores before Store1 may *not* float below Load2 and any</span>
<span class="c1">// subsequent load operations.</span>

<span class="c1">// 省略 acquire and release 部分内容</span>

<span class="c1">// Finally, we define a &quot;fence&quot; operation, as a bidirectional barrier.</span>
<span class="c1">// It guarantees that any memory access preceding the fence is not</span>
<span class="c1">// reordered w.r.t. any memory accesses subsequent to the fence in program</span>
<span class="c1">// order. This may be used to prevent sequences of loads from floating up</span>
<span class="c1">// above sequences of stores.</span>
</pre></div>

<p>通过上面的注释我们知道，JVM根据<code>JSR-133 Cook Book</code>定义了4种基本的内存屏障操作，并由下面的几种作用。</p>
<table>
<thead>
<tr>
<th>内存屏障</th>
<th>使用方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad</td>
<td>Load1 LoadLoad Load2</td>
<td>确保Load1一定是在<br>Load2以及其后的指令之前完成</td>
</tr>
<tr>
<td>StoreStore</td>
<td>Store1 StoreStore Store2</td>
<td>确保 Store1 一定是在<br> Store2 以及其后的指令之前完成<br>（同时，Store1的写入数据会立即被其他 CPU看到</td>
</tr>
<tr>
<td>LoadStore</td>
<td>Load1 LoadStore Store2</td>
<td>确保 Load1 一定是在<br> Store2 以及其后的指令之前完成</td>
</tr>
<tr>
<td>StoreLoad</td>
<td>Store1 StoreLoad Load2</td>
<td>确保 Store1 一定在 <br>Load2 以及其后的指令之前完成</td>
</tr>
</tbody>
</table>
<p>我们看到，在常见的4中基本内存屏障之后，还单独定义了<code>fence</code>操作，<code>fence</code>操作的功能可以说涵盖了上面的4中基本屏障。它可以保证<code>fence</code>前的任何操作op1都在op2之前完成。</p>
<p>JVM为每种屏障类型都定义了一个单独的方法，带代码中如果需要某种屏障可能直接调用。</p>
<div class="highlight"><pre>  <span class="k">static</span> <span class="kt">void</span>     <span class="nf">loadload</span><span class="p">();</span>
  <span class="k">static</span> <span class="kt">void</span>     <span class="nf">storestore</span><span class="p">();</span>
  <span class="k">static</span> <span class="kt">void</span>     <span class="nf">loadstore</span><span class="p">();</span>
  <span class="k">static</span> <span class="kt">void</span>     <span class="nf">storeload</span><span class="p">();</span>

  <span class="k">static</span> <span class="kt">void</span>     <span class="nf">acquire</span><span class="p">();</span>
  <span class="k">static</span> <span class="kt">void</span>     <span class="nf">release</span><span class="p">();</span>
  <span class="k">static</span> <span class="kt">void</span>     <span class="nf">fence</span><span class="p">();</span>
</pre></div>

<h1 id="volatile">volatile和硬件的关系<a class="headerlink" href="#volatile" title="Permanent link"></a></h1>
<p><code>volatile</code>在上面提到的两个功能，都是通过JVM定义的内存屏障来实现的。
而JVM定义的内存屏障可以理解是一个规范，它要求不管在什么平台上都要有同样的效
果。但是最终还是要依靠硬件来实现。所以们可以看到，在JVM中对于各种硬件平台都有对应的内存屏障实现。</p>
<p><img alt="" src="/img/fence.png" /></p>
<p>因为我们在服务器领域还是使用Linux比较多，而且大部分使用的是Intel的CPU，所以下面我们先关注一下<code>linux_x86</code>的实现</p>
<h2 id="linux_x86">linux_x86内存屏障实现<a class="headerlink" href="#linux_x86" title="Permanent link"></a></h2>
<p><div class="highlight"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">compiler_barrier</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">__asm__</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="n">OrderAccess</span><span class="o">::</span><span class="n">loadload</span><span class="p">()</span>   <span class="p">{</span> <span class="n">compiler_barrier</span><span class="p">();</span> <span class="p">}</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">OrderAccess</span><span class="o">::</span><span class="n">storestore</span><span class="p">()</span> <span class="p">{</span> <span class="n">compiler_barrier</span><span class="p">();</span> <span class="p">}</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">OrderAccess</span><span class="o">::</span><span class="n">loadstore</span><span class="p">()</span>  <span class="p">{</span> <span class="n">compiler_barrier</span><span class="p">();</span> <span class="p">}</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">OrderAccess</span><span class="o">::</span><span class="n">storeload</span><span class="p">()</span>  <span class="p">{</span> <span class="n">fence</span><span class="p">();</span>            <span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="n">OrderAccess</span><span class="o">::</span><span class="n">acquire</span><span class="p">()</span>    <span class="p">{</span> <span class="n">compiler_barrier</span><span class="p">();</span> <span class="p">}</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">OrderAccess</span><span class="o">::</span><span class="n">release</span><span class="p">()</span>    <span class="p">{</span> <span class="n">compiler_barrier</span><span class="p">();</span> <span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="n">OrderAccess</span><span class="o">::</span><span class="n">fence</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">os</span><span class="o">::</span><span class="n">is_MP</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// always use locked addl since mfence is sometimes expensive</span>
<span class="cp">#ifdef AMD64</span>
    <span class="n">__asm__</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;lock; addl $0,0(%%rsp)&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="cp">#else</span>
    <span class="n">__asm__</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;lock; addl $0,0(%%esp)&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
  <span class="p">}</span>
  <span class="n">compiler_barrier</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
我们看上面用到的<code>fence()</code>和<code>storeload()</code>方法，都其实最终调用的都是<code>fence()</code>方法。其他的都是调用的<code>compiler_barrier()</code>方法。
然后这里两个方法里面都是使用的内嵌汇编指令的方式，所以我们下来分析一下这个内嵌汇编指令的格式。</p>
<h3 id="_1">内嵌汇编指令<a class="headerlink" href="#_1" title="Permanent link"></a></h3>
<p>内嵌汇编指令的格式是 </p>
<p><code>__asm__　__volatile__("Instruction List" : Output : Input : Clobber/Modify);</code></p>
<ul>
<li><code>__asm__</code>或<code>asm</code> 用来声明一个内联汇编表达式，所以任何一个内联汇编表达式都是以它开头的，是必不可少的。</li>
<li><span style='color:red'><code>__volatile__</code>或<code>volatile</code> 是可选的。如果用了它，表示防止编译器对代码块进行优化。</span><ul>
<li>而这里的优化是针对代码块而言的，使用嵌入式汇编的代码分成三块：</li>
<li>嵌入式汇编之前的代码块</li>
<li>嵌入式汇编代码块</li>
<li>嵌入式汇编之后的c代码块</li>
<li>所以使用了<code>volatile</code>修饰的内嵌汇编的意思是，防止编译器对汇编代码块及前后的代码进行重排序等优化。</li>
</ul>
</li>
<li><code>Instruction List</code> 是要执行的汇编指令序列。它可以是空的。</li>
<li><code>Output</code>和<code>Input</code>是汇编指令中的输入和输出，都可以为空，这里我们不做过多分析</li>
<li><code>Clobber/Modify</code>是寄存器/内存修改标示。通知GCC当前内联汇编语句可能会对某些寄存器或内存进行修改,希望GCC在编译时能够将这一点考虑进去,这会对GCC在编译的时候有一些影响，但具体是什么影响我们就不深究了。</li>
</ul>
<hr />
<p>了解了内嵌汇编代码的格式，我们再来看上面的两个方法。</p>
<p><code>compiler_barrier()</code>：<code>__asm__ volatile ("" : : : "memory");</code> </p>
<p>禁止编译器对汇编代码前后的代码块，进行重排序等优化，并且告诉编译器我修改了memory中的内容</p>
<p><code>fence()</code>:<code>__asm__ volatile ("lock; addl $0,0(%%esp)" : : : "cc", "memory");</code></p>
<p>禁止编译器对汇编代码前后的代码块，进行重排序等优化,并且执行 </br><code>lock; addl $0,0(%%esp)</code>这条汇编指令，并且告诉编译器我修改了memory中的内容</p>
<h3 id="lock">Lock前缀指令<a class="headerlink" href="#lock" title="Permanent link"></a></h3>
<p>通过上面我们已经知道，JVM通过使用带有<code>volatile</code>关键字的内嵌汇编的方便，解决了编译器重排序的问题。那么CPU级别的重排序，和内存间的可见性是怎么实现的呢，下面我们就要用到Lock指令了。</p>
<p>我们看到在<code>fence()</code>方法内嵌的汇编代码中，使用了<code>lock前缀</code>指令，那<code>lock前缀</code>指令在这里起到的是什么作用呢。</p>
<h4 id="lock_1">Lock前缀指令的作用<a class="headerlink" href="#lock_1" title="Permanent link"></a></h4>
<p>在Intel 用户开发手册中关于<code>lock前缀</code>有这样的描述。</p>
<p><a href="https://www.intel.cn/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-system-programming-manual-325384.pdf">Intel开发手册下载地址</a></p>
<p><code>8.1- LOCKED ATOMIC OPERATIONS</code> </p>
<blockquote>
<p>The processor uses three interdependent mechanisms for carrying out locked atomic operations:</p>
<p>• Guaranteed atomic operations </p>
<p>• Bus locking, using the LOCK# signal and the LOCK instruction prefix</p>
<p>• Cache coherency protocols that ensure that atomic operations can be carried out on cached data structures (cache lock); this mechanism is present in the Pentium 4, Intel Xeon, and P6 family processors</p>
</blockquote>
<p>意思是，我们有3种方式可以实现CPU的原子操作</p>
<ol>
<li>使用被保证的原子操作，比如读写1byte等</li>
<li>使用<code>lock</code>指令作为指令前缀</li>
<li>使用缓存一致性协议</li>
</ol>
<p>所以使用<code>lock</code>指令作为前缀，能够把它后面的一个或者几个操作&rsquo;包装&rsquo;为一个原子操作。不过你可能会想，那这么说来<code>lock</code>的作用和我们使用它的目前好像不大一样啊，可见性呢？重排序呢？别急我们继续看。</p>
<h4 id="lock_2">Lock前缀保证可见性<a class="headerlink" href="#lock_2" title="Permanent link"></a></h4>
<p><code>lock前缀</code>指令的实现方法，在早期CPU和现代CPU中有很大不同,我们还是引用开发手册中的描述</p>
<p><code>8.1.2-Bus Locking</code> </p>
<blockquote>
<p>In the case of the Intel386, Intel486, and Pentium processors, explicitly locked instructions will result in the asser- tion of the LOCK# signal. It is the responsibility 
of the hardware designer to make the LOCK# signal available in system hardware to control memory accesses among processors.</p>
<p>For the P6 and more recent processor families, if the memory area being accessed is cached internally in the processor, the LOCK# signal is generally not asserted; 
instead, locking is only applied to the processor’s caches</p>
</blockquote>
<p>意思是，在早期的CPU中，当使用<code>lock前缀</code>指令时候，会导致产生一个<code>LOCK#</code>信号，通过总线锁定对应的内存，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放。
在后来的处理器的处理逻辑中，如果要操作的内存，已经cache到了处理器的缓存中，那么将不会产生<code>LOCK#</code>信号，则通过缓存一致性协议来完成原子性的保证。</p>
<p><code>8.1.4-Effects of a LOCK Operation on Internal Processor Caches</code> </p>
<blockquote>
<p>For the P6 and more recent processor families, if the area of memory being locked during a LOCK operation is
cached in the processor that is performing the LOCK operation as write-back memory and is completely contained
in a cache line, the processor may not assert the LOCK# signal on the bus. Instead, it will modify the memory location internally and allow it’s cache coherency mechanism to ensure that the operation is carried out atomically. This
operation is called “cache locking.” The cache coherency mechanism automatically prevents two or more processors that have cached the same area of memory from simultaneously modifying data in that area.</p>
</blockquote>
<p>意思是：<span style="color: red;">在LOCK操作中被锁定的内存区域是缓存在执行<code>LOCK</code>操作的处理器中，作为回写存储器，并且完全包含在缓存行中。在一个缓存行中，处理器可能不会在总线上发出<code>LOCK#</code>信号。相反，它将在内部修改内存位置，并允许它的缓存一致性机制确保该操作是原子式进行的。这种操作被称为&rdquo;高速缓存锁定&rdquo;。缓存一致性机制会自动防止两个或更多的处理器在缓存同一区域的内存上同时修改该区域的数据。</span></p>
<p>显而易见，使用<code>总线锁定</code>的方式代价要大得多。不过目前在大多数情况下，我们在使用<code>lock</code>指令的时候，都是通过缓存一致性协议来保证的后面操作的原子性操作。但是有一些情况同样也会导致不能使用<code>高速缓存锁定</code>，而只能使用<code>总线锁定</code>，比如涉及到的数据跨越多个CacheLine，CPU不支持缓存锁定等。</p>
<ul>
<li>在 Pentium 和早期的 IA-32 处理器中，lock 前缀会使处理器执行当前指令时产生一个 LOCK# 信号，会对总线进行锁定，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放</li>
<li>后来的处理器，加锁操作是由高速缓存锁代替总线锁来处理。 因为锁总线的开销比较大，锁总线期间其他CPU没法访问内存。 这种场景多缓存的数据一致通过缓存一致性协议(MESI)来保证。</li>
</ul>
<p>所以总结一下，当我们使用<code>lock前缀</code>指令的时候会发生这两件事</p>
<ul>
<li>要操作的数据在缓存中，会导致其他CPU的缓存行失效</li>
<li>如果数据不再内存中，则会使用总线锁定，把内存中的数据读入或者写出到内存。同时也会导致其他CPU的缓存行失效。</li>
</ul>
<p>所以使用<code>lock前缀</code>指令，会通过触发缓存一致性协议导致关联的缓存行失效，从而保证可见性。</p>
<p>可见性我们知道了，那么防止指令重排序的作用呢？我们继续在用户手册中寻找一下答案。</p>
<h4 id="lock_3">Lock前缀防止指令重排<a class="headerlink" href="#lock_3" title="Permanent link"></a></h4>
<p><code>8.2.5 Strengthening or Weakening the Memory-Ordering Model</code></p>
<blockquote>
<p>The Intel 64 and IA-32 architectures provide several mechanisms for strengthening or weakening the memory-
ordering model to handle special programming situations. These mechanisms include:</p>
<p>• The I/O instructions, locking instructions, the LOCK prefix, and serializing instructions force stronger 
ordering on the processor. </p>
<p>• The SFENCE instruction (introduced to the IA-32 architecture in the Pentium III processor) and the LFENCE 
and MFENCE instructions (introduced in the Pentium 4 processor) provide memory-ordering and serialization 
capabilities for specific types of memory operations.</p>
<p>&hellip; 省略部分</p>
<p>Synchronization mechanisms in multiple-processor systems may depend upon a strong memory-ordering model. 
Here, a program can use a locking instruction such as the XCHG instruction or the LOCK prefix to ensure that
a read-modify-write operation on memory is carried out atomically. Locking operations typically operate like
I/O operations in that they wait for all previous instructions to complete and for all buffered writes to 
drain to memory</p>
</blockquote>
<p>意思是，Intel处理器提供了几种机制用来加强或者削弱内存排序。其中使用IO相关指令、锁定指令、LOCK前缀指令、序列化相关指令都能够强化
排序。(<span style="color: red;">这里强化的意思是，更加按照指令流的顺序来执行,也就是减少处理器的重排序</span>)</p>
<p>在程序中可以使用锁定指令，或者<code>lock前缀</code>指令来强化排序，它们会等待所有先前的指令完成，并等待所有缓冲的写操作耗尽到内存中。</p>
<p>所以我们看到，JVM通过内嵌<code>lock前缀</code>的汇编指令，保证了可见性和防止了内存重排序。</p>
<h3 id="lock_4">Lock前缀指令的其他应用<a class="headerlink" href="#lock_4" title="Permanent link"></a></h3>
<p>我们经常使用的CAS的底层，也是使用<code>lock前缀</code>实现的，使用<code>lock</code>指令保证了后面的操作的原子性。</p>
<h3 id="x86storeload">为何x86只实现了storeload内存屏障<a class="headerlink" href="#x86storeload" title="Permanent link"></a></h3>
<p>还有一点我们在上面的x86的实现中看到，只有<code>fence()</code>方法，和<code>storeload()</code>方法使用<code>lock前缀</code>指令，其他的几种都是只是实现了编译器级别的内存屏障，也就是只能防止编译器的指令重排序。这是为什么呢？</p>
<p>同样我们在操作手册中寻找一下答案，在操作手册的 <code>8.2.3-Examples Illustrating the Memory-Ordering</code>章节，说明x86处理器对<code>store</code>和<code>load</code>指令的重排序情况</p>
<ul>
<li>8.2.3.2 Neither Loads Nor Stores Are Reordered with Like Operations</li>
<li>8.2.3.3 Stores Are Not Reordered With Earlier Loads</li>
<li>8.2.3.4 Loads May Be Reordered with Earlier Stores to Different Locations</li>
</ul>
<p>意思是
- <code>load</code>指令和<code>store</code>指令，都不能喝同类型的指令之间发生重排序，也就是 load1,load2 和 store1，store2 是不会发生重排序的
- <code>store</code>指令和前面出现的<code>load</code>指令，不会重排序，也就是 load1,store2 不会发生重排序。
- <code>load</code>指令，和它前面出现的<code>store</code>指令之间可能会发生重排序。</p>
<p>看到这，我们能知道，x86的CPU，在不添加任何内存屏障的情况下，已经支持了<code>loadload</code>,<code>storestore</code>,<code>loadstore</code>屏障了。只有<code>storeload</code>这种需要单独添加内存屏障来保证不会重排序。</p>
<p>所以对于x86处理器原生支持的3种屏障，只需要保证编译器不会发生重排序即可。</p>
<p>所以说，volatile的实现和硬件平台关系非常密切。</p>
<p>|处理器|   Load-Load   |Load-Store|    Store-Store|    Store-Load| 数据依赖|
|x86|   N   |N  N   Y   N
PowerPC Y   Y   Y   Y   N
ia64    Y   Y   Y   Y   N</p>
<h3 id="x86jvmlock">为何x86下JVM使用LOCK前缀实现内存屏障<a class="headerlink" href="#x86jvmlock" title="Permanent link"></a></h3>
<p>在Intel的处理器平台下内存屏障分为两类：</p>
<ul>
<li>本身是内存屏障，比如“lfence”，“sfence”和“mfence”汇编指令</li>
<li>本身不是内存屏障，但是被LOCK指令前缀修饰，其组合成为一个内存屏障。在X86指令体系中，其中一类内存屏障常使用“LOCK指令前缀加上一个空操作”方式实现，比如<code>lock addl $0x0,(%esp)</code></li>
</ul>
<p>所以有一个疑问，为什么JVM选择使用<code>lock前缀</code>指令来实现内存屏障而不使用专门的内存屏障指令呢？</p>
<p>我在JVM的源码中搜索了一下<code>mfence</code>,搜索到了下面几段注释</p>
<p><code>macroAssembler_x86.cpp</code>
<div class="highlight"><pre><span class="c1">// We have a classic Dekker-style idiom:</span>
<span class="c1">//    ST m-&gt;_owner = 0 ; MEMBAR; LD m-&gt;_succ</span>
<span class="c1">// There are a number of ways to implement the barrier:</span>
<span class="c1">// (1) lock:andl &amp;m-&gt;_owner, 0</span>
<span class="c1">//     is fast, but mask doesn&#39;t currently support the &quot;ANDL M,IMM32&quot; form.</span>
<span class="c1">//     LOCK: ANDL [ebx+Offset(_Owner)-2], 0</span>
<span class="c1">//     Encodes as 81 31 OFF32 IMM32 or 83 63 OFF8 IMM8</span>
<span class="c1">// (2) If supported, an explicit MFENCE is appealing.</span>
<span class="c1">//     In older IA32 processors MFENCE is slower than lock:add or xchg</span>
<span class="c1">//     particularly if the write-buffer is full as might be the case if</span>
<span class="c1">//     if stores closely precede the fence or fence-equivalent instruction.</span>
<span class="c1">//     See https://blogs.oracle.com/dave/entry/instruction_selection_for_volatile_fences</span>
<span class="c1">//     as the situation has changed with Nehalem and Shanghai.</span>
<span class="c1">// (3) In lieu of an explicit fence, use lock:addl to the top-of-stack</span>
<span class="c1">//     The $lines underlying the top-of-stack should be in M-state.</span>
<span class="c1">//     The locked add instruction is serializing, of course.</span>
<span class="c1">// (4) Use xchg, which is serializing</span>
<span class="c1">//     mov boxReg, 0; xchgl boxReg, [tmpReg + Offset(_owner)-2] also works</span>
<span class="c1">// (5) ST m-&gt;_owner = 0 and then execute lock:orl &amp;m-&gt;_succ, 0.</span>
<span class="c1">//     The integer condition codes will tell us if succ was 0.</span>
<span class="c1">//     Since _succ and _owner should reside in the same $line and</span>
<span class="c1">//     we just stored into _owner, it&#39;s likely that the $line</span>
<span class="c1">//     remains in M-state for the lock:orl.</span>
<span class="c1">//</span>
<span class="c1">// We currently use (3), although it&#39;s likely that switching to (2)</span>
<span class="c1">// is correct for the future.</span>
</pre></div></p>
<p><code>orderAccess_linux_x86.inline.hpp</code>
<div class="highlight"><pre><span class="c1">// always use locked addl since mfence is sometimes expensive</span>
</pre></div></p>
<p>大概意思就是说，<code>mfence</code>目前有几个缺点 </p>
<p>1.并不是所有cpu都支持这个指令。
2. 在最早前的CPU中性能比<code>lock前缀</code>差一些。
3. 有时<code>mfence</code>的性能损耗比较严重</p>
<p>所以基于以上考虑，目前还是使用<code>lock前缀</code>(我查看的jvm源码是jdk11的)，但是未来很有可能改为使用<code>mfence</code>指令。</p>
<p><a href="https://blogs.oracle.com/dave/instruction-selection-for-volatile-fences-%3a-mfence-vs-lock%3aadd">Instruction selection for volatile fences : MFENCE vs LOCK:ADD</a></p>
<h2 id="_2">缓存一致性协议<a class="headerlink" href="#_2" title="Permanent link"></a></h2>
<p>在上面我们不止一次的提到了缓存一致性协议，那么缓存一致性协议具体是什么样的呢？下面我们来简单的了解一下。</p>
<p>现在处理器处理能力上要远胜于主内存（DRAM），主内存执行一次内存读写操作，所需的时间可能足够处理器执行上百条的指令，为了弥补处理器与主内存处理能力之间的鸿沟，引入了高速缓（Cache),来保存一些CPU从内存读取的数据，下次用到该数据直接从缓存中获取即可，以加快读取速度，随着多核时代的到来,每块CPU都有多个内核，每个内核都有自己的缓存，这样就会出现同一个数据的副本就会存在于多个缓存中，在读写的时候就会出现数据 不一致的情况。</p>
<h3 id="_3">缓存行<a class="headerlink" href="#_3" title="Permanent link"></a></h3>
<p>数据在缓存中不是以独立的项来存储的，它不是一个单独的变量，也不是一个单独的指针,它在数据缓存中以缓存行存在的，也称缓存行为缓存条目。目前主流的CPU Cache的Cache Line大小通常是<code>64字节</code>，并且它有效地引用主内存中的一块地址。</p>
<h4 id="_4">局部性原理<a class="headerlink" href="#_4" title="Permanent link"></a></h4>
<p>局部性原理：在CPU访问存储设备时，无论是存取数据或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理。</p>
<ul>
<li>时间局部性（<code>Temporal Locality</code>）：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。比如程序中的循环、递归对数据的循环访问，
主要体现在指令读取的局部性</li>
<li>空间局部性（<code>Spatial Locality</code>）：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。比如程序中的数据组的读取或者对象的连续创建，
对内存都是顺序的读写，主要体现在对程序数据引用的局部性</li>
</ul>
<h3 id="mesi">MESI协议<a class="headerlink" href="#mesi" title="Permanent link"></a></h3>
<p><code>MESI</code>是众多缓存一致性协议中的一种，也在Intel系列中广泛使用的缓存一致性协议
缓存行（Cache line）的状态有<code>Modified</code>、<code>Exclusive</code>、 <code>Share</code> 、<code>Invalid</code>，而MESI 
命名正是以这4中状态的首字母来命名的。该协议要求在每个缓存行上维护两个状态位，使得每个数据单位可能处于M、E、S和I这四种状态之一。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
<th align="center">监听任务</th>
</tr>
</thead>
<tbody>
<tr>
<td>M</td>
<td>该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</td>
<td align="center">缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</td>
</tr>
<tr>
<td>E</td>
<td>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</td>
<td align="center">缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</td>
</tr>
<tr>
<td>S</td>
<td>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</td>
<td align="center">缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）</td>
</tr>
<tr>
<td>I</td>
<td>该Cache line无效。</td>
<td align="center">无</td>
</tr>
</tbody>
</table>
<h4 id="_5">监听任务<a class="headerlink" href="#_5" title="Permanent link"></a></h4>
<ul>
<li>一个处于M状态的缓存行，必须时刻监听所有试图读取该缓存行对应的主存地址的操作，如果监听到，则必须在此操作执行前把其缓存行中的数据写回主内存</li>
<li>一个处于S状态的缓存行，必须时刻监听使该缓存行无效或者独享该缓存行的请求，如果监听到，则必须把其缓存行状态设置为I。</li>
<li>一个处于E状态的缓存行，必须时刻监听其他试图读取该缓存行对应的主存地址的操作，如果监听到，则必须把其缓存行状态设置为S</li>
</ul>
<h4 id="_6">嗅探协议<a class="headerlink" href="#_6" title="Permanent link"></a></h4>
<p>上面提到的监听任务大多数都是通过嗅探(snooping)协议来完成的</p>
<blockquote>
<p>“窥探”背后的基本思想是，所有内存传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线：缓存本身是独立的，但是内存是共享资源，
所有的内存访问都要经过仲裁（arbitrate）：同一个指令周期中，只有一个缓存可以读写内存。窥探协议的思想是，缓存不仅仅在做内存传输的时候才和总线打交道，
而是不停地在窥探总线上发生的数据交换，跟踪其他缓存在做什么。所以当一个缓存代表它所属的处理器去读写内存时，其他处理器都会得到通知，
它们以此来使自己的缓存保持同步。只要某个处理器一写内存，其他处理器马上就知道这块内存在它们自己的缓存中对应的段已经失效。</p>
</blockquote>
<h4 id="mesi_1">MESI读取缓存流程<a class="headerlink" href="#mesi_1" title="Permanent link"></a></h4>
<p>CPU1需要读取数据X，会根据数据的地址在自己的缓存L1A中找到对应的缓存行,然后判断缓存行的状态</p>
<ul>
<li>如果缓存行的状态是<code>M、E、S</code>，说明该缓存行的数据对于当前读请求是可用的，则可以直接使用</li>
<li>如果缓存行的状态是I，则说明该缓存行的数据是无效的，则CPU1会向总线发送<code>Read</code>消息，说’我现在需要地址A的数据，谁可以提供？‘，其它处理器会CPU2监听总线上的消息，收到消息后，会从消息中解析出需要读取的地址，
然后在自己缓存中查找缓存行，这时候根据找到缓存行的状态会有以下几种情况<ul>
<li>状态为<code>S/E</code> , CPU2会构造<code>Read Response</code>消息，将相应缓存行中的数据放到消息中，发送到总线同时更新自己缓存行的状态为<code>S</code>，CPU1收到响应消息后，会将消息中的数据存入相应的缓存行中，同时更新缓存行的状态为<code>S</code></li>
<li>状态为<code>M</code>，会先将自己缓存行中的数据写入主内存，并响应<code>Read Response</code>消息同时将L1B中的相应的缓存行状态更新为<code>S</code></li>
<li>状态为I或者在自己的缓存中不存在X的数据，那么主内存会构造<code>Read Response</code>消息，从主内存读取包含指定地址的块号数据放入消息（缓存行大小和内存块大小一致所以可以存放的下），并将消息发送到总线</li>
</ul>
</li>
<li>CPU1获接收到总线消息之后，解析出数据保存在自己的缓存中</li>
</ul>
<h4 id="mesi_2">MESI写缓存流程<a class="headerlink" href="#mesi_2" title="Permanent link"></a></h4>
<p>CPU1 需要写入数据X</p>
<ul>
<li>为<code>E/M</code>时，说明当前CPU1已经拥有了相应数据的所有权，此时CPU1会直接将数据写入缓存行中，并更新缓存行状态为<code>M</code>，此时不需要向总线发送任何消息。</li>
<li><code>S</code>时，说明数据被共享，其它CPU中有可能存有该数据的副本，则CPUA向总线发送<code>Invalidate</code> 消息以获取数据的所有权，其它处理器（CPU2)收到<code>Invalidate</code>消息后,会将其高速缓存中相应的缓存行状态更新为<code>I</code>，表示已经逻辑删除相应的副本数据，
并回复<code>Invalidate Acknowledge</code>消息，CPU1收到所有处理器的响应消息后，会将数据更新到相应的缓存行之中，同时修改缓存行状态为<code>E</code>，此时拥有数据的所有权，会对缓存行数据进行更新，最终该缓存行状态为<code>M</code></li>
<li><code>I</code>时，说明当前处理器中不包含该数据的有效副本，则CPU1向总线发送<code>Read Invalidate</code>消息<code>，表明</code>我要读数据X，希望主存告诉我X的值，同时请示其它处理器将自己缓存中包含该数据的缓存行并且状态不是I的缓存行置为无效`</li>
<li>其它处理器（CPUB)收到<code>Invalidate</code>消息后，如果缓存行不为<code>I</code>的话，会将其高速缓存中相应的缓存行状态更新为<code>I</code>，表示已经逻辑删除相应的副本数据，并回复<code>Invalidate Acknowledge消息</code></li>
<li>主内存收到<code>Read</code>消息后，会响应<code>Read Response</code>消息将需要读取的数据告诉CPU1</li>
<li>CPU1收到所有处理器的<code>Invalidate Acknowledge</code>消息和主内存的<code>Read Response</code>消息后，会将数据更新到相应的缓存行之中，同时修改缓存行状态为<code>E</code>，此时拥有数据的所有权，会对缓存行数据进行更新，最终该缓存行状态为<code>M</code></li>
</ul>
<h4 id="mesi_3">MESI的状态变化<a class="headerlink" href="#mesi_3" title="Permanent link"></a></h4>
<p><img alt="" src="/img/20200220235854870.png" /></p>
<ul>
<li>Local Read：表示本内核读本Cache中的值</li>
<li>Local Write：表示本内核写本Cache中的值</li>
<li>Remote Read：表示其它内核读其Cache中的值</li>
<li>Remote Write：表示其它内核写其Cache中的值</li>
<li>箭头表示本Cache line状态的迁移，环形箭头表示状态不变</li>
</ul>
<h3 id="storebufferinvalidate-queue">StoreBuffer和Invalidate Queue<a class="headerlink" href="#storebufferinvalidate-queue" title="Permanent link"></a></h3>
<p><img alt="" src="/img/aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvY29udGVudC91cGxvYWRmaWxlLzIwMTUxMi85N2FiZTRkOTNlNmYwNjM5N2FjMWNjZDQ1OWNhNzVlOTIwMTUxMjEwMTExMDM3LmdpZg.png" /></p>
<p>说了缓存一致性协议，好像就能够解决问题了，但是，在这里你会发现，又有新的问题出现了。MESI协议中：当cpu0写数据到本地cache的时候，如果不是M或者E状态，需要发送一个<code>invalidate</code>消息给cpu1，只有收到cpu1的ack之后cpu0才能继续执行，
在这个过程中cpu0需要等待，这大大影响了性能。于是CPU设计者引入了<code>Store Buffer</code>，这个buffer处于CPU与cache之间。</p>
<p><img alt="" src="/img/storebuffer1.png" /></p>
<p><code>Store Buffer</code>增加了CPU连续写的性能，同时把各个CPU之间的通信的任务交给缓存一致性协议。但是<code>Store Buffer</code>仍然引入了一些复杂性,那就是缓存数据和<code>Store Buffer</code>数据不一致的问题。</p>
<h4 id="store-forwarding">Store Forwarding<a class="headerlink" href="#store-forwarding" title="Permanent link"></a></h4>
<p>为了解决上面的问题，修改为了下面的架构，这种设计叫做<code>Store forwarding</code>，当CPU执行load操作的时候，不但要看cache，还有看<code>Store Buffer</code>是否有内容，如果<code>Store Buffer</code>有该数据，那么就采用<code>Store Buffer</code>中的值。</p>
<p><img alt="" src="/img/20200221154806152.png" /></p>
<h4 id="invalid-queue">Invalid Queue<a class="headerlink" href="#invalid-queue" title="Permanent link"></a></h4>
<p>同样的问题也会出现在其他线程发送<code>Invalidate Acknowledge</code>消息的时候，通常<code>Invalidate Cacheline</code>操作没有那么快完成,尤其是在Cache繁忙的时候，这时CPU往往进行密集的<code>load</code>和<code>store</code>的操作，而来自其他CPU的，
对本CPU Cache的操作需要和本CPU的操作进行竞争，只有完成了<code>invalidate</code>操作之后，本CPU才会发生<code>invalidate acknowledge</code>。此外，如果短时间内收到大量的<code>invalidate</code>消息，CPU有可能跟不上处理，从而导致其他CPU不断的等待。
为了解决这个问题，引入了<code>Invalid Queue</code>,系统架构如下。</p>
<p><img alt="" src="/img/invaidQueue.png" /></p>
<p>有了<code>Invalidate Queue</code>的CPU，在收到<code>invalidate</code>消息的时候首先把它放入<code>Invalidate Queue</code>，同时立刻回送<code>acknowledge</code> 消息，无需等到该cacheline被真正invalidate之后再回应。当然，如果本CPU想要针对某个cacheline向总线发送invalidate消息的时候，
那么CPU必须首先去<code>Invalidate Queue</code>中看看是否有相关的cacheline，如果有，那么不能立刻发送，需要等到<code>Invalidate Queue</code>中的cacheline被处理完之后再发送。</p>
<h2 id="_7">乱序执行/重排序<a class="headerlink" href="#_7" title="Permanent link"></a></h2>
<p>了解完上面的这些知识，我们再来整体的总结一下乱序执行或者说重排序的问题。</p>
<p>重排序从发生的环节上来分，可以分为2大类</p>
<ul>
<li>编译器重排序</li>
<li>处理器重排序</li>
</ul>
<p>下面我们分别来说一下。 </p>
<h3 id="_8">编译器乱序<a class="headerlink" href="#_8" title="Permanent link"></a></h3>
<p>编译器重排序：编译器会对高级语言的代码进行分析，当编译器认为你的代码可以优化的话，编译器会选择对代码进行优化，重新排序，然后生成汇编代码。当然这个优化是有原则的，原则就是在保证单线程下的执行结果不变。</p>
<p>编译器在编译时候，能够获得最底层的信息，比如要读写哪个寄存器，读写哪块内存。所以编译就根据这些信息对代码进行优化，包括不限于减少无用变量、修改代码执行顺序等等。
<code>优秀的编译器优化能够提升程序在CPU上的运行性能，更好的使用寄存器以及现代处理器的流水线技术，减少汇编指令的数量，降低程序执行需要的CPU周期，减少CPU读写主存的时间</code>。</p>
<p>当然，编译器在优化的时候，只能保证在单线程下的结果，</p>
<p>demo</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">A</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">B</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="mi">10</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">C</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>假设编译器通过复杂的分析发现A不在缓存中，而C在缓存中，因此，A=10将触发多周期的数据加载，而C=20则可以在单个周期内完成，编译器可以直接跳过对A=10和B=A+10进行赋值操作而执行C=20&gt;。</p>
<h3 id="_9">处理器乱序<a class="headerlink" href="#_9" title="Permanent link"></a></h3>
<ul>
<li>在没有数据依赖的情况下，为提高流水线的工作效率，而对指令进行重排序</li>
<li>由于缓存的存在，虽然是按顺序执行，但是也会出现乱序的结果</li>
</ul>
<h2 id="_10">伪共享问题<a class="headerlink" href="#_10" title="Permanent link"></a></h2>
<h2 id="volatile_1">volatile使用中的优化<a class="headerlink" href="#volatile_1" title="Permanent link"></a></h2>
<h1 id="_11">参考<a class="headerlink" href="#_11" title="Permanent link"></a></h1>
<p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-volatile.html">[关键字: volatile详解]</a></p>
<p><a href="https://dslztx.github.io/blog/2019/06/08/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%9A%84LOCK%E6%8C%87%E4%BB%A4%E5%89%8D%E7%BC%80/">[汇编指令的LOCK指令前缀]</a></p>
<p><a href="https://monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/">[一文了解内存屏障]</a></p>
<p><a href="https://blog.csdn.net/qq_26222859/article/details/52240256">[volatile与内存屏障]</a></p>
<p><a href="https://segmentfault.com/a/1190000022508589">[内存屏障及其在JVM内的应用]</a></p>
<p><a href="https://www.cnblogs.com/yanlong300/p/8986041.html">[CPU缓存一致性协议MESI]</a></p>
<p><a href="https://zh.wikipedia.org/wiki/X86">[x86架构]</a></p>
<p><a href="https://albk.tech/%E8%81%8A%E8%81%8A%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE.html">[聊聊缓存一致性协议]</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24146167">[浅论Lock与X86 Cache一致性]</a></p>
<p><a href="https://blog.csdn.net/reliveIT/article/details/105902477?spm=1001.2014.3001.5501">[Why Memory Barriers？中文翻译（上）]</a></p>
<p><a href="https://blog.csdn.net/b_x_p/article/details/104382767">[Volatile全面解析，实现原理及作用分析]</a></p></article></body></html>