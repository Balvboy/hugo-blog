---
title: "MySQL的事务、日志、锁和MVCC"
date: 2021-07-28T10:53:40+08:00
author:     "zhouyang"
draft: true
tags:
    - mysql
categories: [ MySQL ]   

---
# MySQL的存储引擎
MySQL有多种可选的存储引擎，常见的有

- InnoDB
- MyISAM
- Memory

其中InnoDB是最常用的存储引擎，并且也是目前MySQL的默认存储引擎。
其中最重要的原因就是，InnoDB支持事务，支持行级锁定。

想了解更多的不同存储引擎的区别，可以查看
[MySQL存储引擎的区别和比较](https://blog.csdn.net/zgrgfr/article/details/74455547)

# MySQL的事务
事务是数据库执行过程中的一个逻辑单位，它可能由一条或多条数据库操作组成。

## 开启事务
在MySQL中

- 对于单条SQL语句，数据库系统自动将其作为一个事务执行，并自动提交事务，这种事务被称为隐式事务。
- 对于多条操作，如果想要放到一个事务中，则需要手动开启事务，并提交

```SQL
begin;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
commit;

```

## 事务的特性

ACID是我们非常熟悉的事务的特性，它指的是数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（Transaction）是正确可靠的，所必须具备的四个特性:

- 原子性(Atomicity):

  一个事务中的操作要么全部完成，要么全部不完成，不可分割

- 一致性(Consistency):

  下面首先给出wiki中关于一致性行的定义

  >在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等

  但是我认为这个解释不够清晰，我个人更倾向于知乎[如何理解数据库的一致性](https://www.zhihu.com/question/31346392)中的一个解释

  >保证事务开始和结束之间的中间状态不会被其他事务看到

- 隔离性(Isolation):

  隔离性的原本意思是，保证事务之间的操作是互相不可见，也就是每个事务都是隔离开的。
  但是实现最高的隔离性，性能很低，同时很多业务场景也并不需要最高的隔离性和一致性。
  所以就提出了几种不同的隔离级别来适当的破坏一致性来提升性能与并行度。


- 持久性(Durability):

  事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

## 关于事务的理解

同样还是在上面提到的那个知乎回答中[如何理解数据库的一致性](https://www.zhihu.com/question/31346392)，提到了为什么会有事务的问题，我觉得挺对的。

总结一下，意思大概是`事务这个概念本身，并不是数据库天生就有的。而是伴随着应用开发出现的各种各样的问题，为了解决这样的问题，并简化应用程序的编程模型而逐渐产生，或者说被提炼出来的。`

对于这种概念性的知识确实比较容易搞偏，陷入不必要，所以我们打住，来看一下技术实现。

## InnoDB对事务特性的实现

可以说InnoDB中的锁、redo log、undo log、MVCC等机制，都是为了实现事务的特性而实现的。下面我们就来简单的分析一下他们都是如何实现的。

### 原子性

MySQL原子性的保证–undo log

原子性的概念是一个事务内的操作要么全执行，要么全不执行。为了解决这个问题，就有了事务回滚的操作。一旦事务执行过程中发生了异常，那么可以通过回滚，把数据回滚。

undo log从字面意思就是撤销日志。负责撤销的日志。

简单理解一下，就是undo log中存储的是和每条纪录相反的操作。比如

- 执行insert，undo log中就存储delete
- 执行delete，undo log中就存储insert
- 执行update，会记录一条相反的update

通过这样的方式，保证在事务中执行失败的时候，数据能够回滚。

当然undo log的作用不仅于此，我们后面会继续分析。


### 持久性
持久性保证的就是，一旦事务提交后，数据一定会保存下来，就算数据库发生错误也不会导致数据丢失。

持久性是依赖 InnoDB的redo log 和 bin log来实现的。
下面我们分析一下MySQL存储一条数据到磁盘的可能方式。
1. 第一种就是每一次更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后在更新，整个过程IO成本，查找成本都很高
2. 第二种先写到内存中的一块区域也就是redo log，就是MySQL里面经常说到的WAL技术，WAL全称为Write-Ahead Logging，他的关键点就是先写日志，再写磁盘。等服务不太忙的时候再把数据写到磁盘。

- 执行器先找到引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行，如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
- 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
- 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。
- 执行器生成这个操作的binlog，并把binlog写入磁盘。
执行器调用引擎提交事务接口，引擎把刚刚写入的redo log改成提交状态，更新完成

参考[MySQL原子性与持久性的保证](https://blog.csdn.net/anying5823/article/details/104675987)

### 隔离性
隔离性最简单的实现方式就是各个事务都串行执行，如果前面的事务还没有执行完毕，后面的事务就都等待。但是这样的实现方式很明显并发效率不高，并不适合在实际环境中使用。
为了解决上述问题，实现不同程度的并发控制，SQL的标准制定者提出了不同的隔离级别，其中最高级隔离级别就是序列化读，而在其他隔离级别中，由于事务是并发执行的，所以或多或少允许出现一些问题。

- 未提交读（read uncommitted）可能发生 脏读、不可重复读、幻读
- 提交读（read committed）可能发生 不可重复读、幻读
- 可重复读（repeatable read）可能发生 幻读
- 序列化读（serializable）没有问题
