---
title: "MySQL的事务、日志、锁和MVCC"
date: 2021-07-28T10:53:40+08:00
author:     "zhouyang"
draft: true
tags:
    - mysql
categories: [ MySQL ]   

---
# MySQL的存储引擎
MySQL有多种可选的存储引擎，常见的有

- InnoDB
- MyISAM
- Memory

其中InnoDB是最常用的存储引擎，并且也是目前MySQL的默认存储引擎。
其中最重要的原因就是，InnoDB支持事务，支持行级锁定。

想了解更多的不同存储引擎的区别，可以查看
[MySQL存储引擎的区别和比较](https://blog.csdn.net/zgrgfr/article/details/74455547)

# MySQL的事务
事务是数据库执行过程中的一个逻辑单位，它可能由一条或多条数据库操作组成。

## 开启事务
在MySQL中

- 对于单条SQL语句，数据库系统自动将其作为一个事务执行，并自动提交事务，这种事务被称为隐式事务。
- 对于多条操作，如果想要放到一个事务中，则需要手动开启事务，并提交

```SQL
begin;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
commit;

```

## 事务的特性

ACID是我们非常熟悉的事务的特性，它指的是数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（Transaction）是正确可靠的，所必须具备的四个特性:

- 原子性(Atomicity):

  一个事务中的操作要么全部完成，要么全部不完成，不可分割

- 一致性(Consistency):

  下面首先给出wiki中关于一致性行的定义

  >在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等

  但是我认为这个解释不够清晰，我个人更倾向于知乎[如何理解数据库的一致性](https://www.zhihu.com/question/31346392)中的一个解释

  >保证事务开始和结束之间的中间状态不会被其他事务看到

- 隔离性(Isolation):

  隔离性的原本意思是，保证事务之间的操作是互相不可见，也就是每个事务都是隔离开的。
  但是实现最高的隔离性，性能很低，同时很多业务场景也并不需要最高的隔离性和一致性。
  所以就提出了几种不同的隔离级别来适当的破坏一致性来提升性能与并行度。


- 持久性(Durability):

  事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

## 关于事务的理解

同样还是在上面提到的那个知乎回答中[如何理解数据库的一致性](https://www.zhihu.com/question/31346392)，提到了为什么会有事务的问题，我觉得挺对的。

总结一下，意思大概是`事务这个概念本身，并不是数据库天生就有的。而是伴随着应用开发出现的各种各样的问题，为了解决这样的问题，并简化应用程序的编程模型而逐渐产生，或者说被提炼出来的。`

对于这种概念性的知识确实比较容易搞偏，陷入不必要，所以我们打住，来看一下技术实现。

## InnoDB对事务特性的实现

可以说InnoDB中的锁、redo log、undo log、MVCC等机制，都是为了实现事务的特性而实现的。下面我们就来简单的分析一下他们都是如何实现的。

### 原子性

MySQL原子性的保证–undo log

原子性的概念是一个事务内的操作要么全执行，要么全不执行。为了解决这个问题，就有了事务回滚的操作。一旦事务执行过程中发生了异常，那么可以通过回滚，把数据回滚。

undo log从字面意思就是撤销日志。负责撤销的日志。

简单理解一下，就是undo log中存储的是和每条纪录相反的操作。比如

- 执行insert，undo log中就存储delete
- 执行delete，undo log中就存储insert
- 执行update，会记录一条相反的update

通过这样的方式，保证在事务中执行失败的时候，数据能够回滚。

当然undo log的作用不仅于此，我们后面会继续分析。


### 持久性
持久性保证的就是，一旦事务提交后，数据一定会保存下来，就算数据库发生错误也不会导致数据丢失。

持久性是依赖 InnoDB的redo log 和 bin log来实现的。
下面我们分析一下MySQL存储一条数据到磁盘的可能方式。
1. 第一种就是每一次更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后在更新，整个过程IO成本，查找成本都很高
2. 第二种先写到内存中的一块区域也就是redo log，就是MySQL里面经常说到的WAL技术，WAL全称为Write-Ahead Logging，他的关键点就是先写日志，再写磁盘。等服务不太忙的时候再把数据写到磁盘。

- 执行器先找到引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行，如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
- 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
- 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。
- 执行器生成这个操作的binlog，并把binlog写入磁盘。
执行器调用引擎提交事务接口，引擎把刚刚写入的redo log改成提交状态，更新完成

参考[MySQL原子性与持久性的保证](https://blog.csdn.net/anying5823/article/details/104675987)

### 隔离性
隔离性最简单的实现方式就是各个事务都串行执行，如果前面的事务还没有执行完毕，后面的事务就都等待。但是这样的实现方式很明显并发效率不高，并不适合在实际环境中使用。
为了解决上述问题，实现不同程度的并发控制，SQL的标准制定者提出了不同的隔离级别，其中最高级隔离级别就是序列化读，而在其他隔离级别中，由于事务是并发执行的，所以或多或少允许出现一些问题。

- 未提交读（read uncommitted）可能发生 脏读、不可重复读、幻读
- 提交读（read committed）可能发生 不可重复读、幻读
- 可重复读（repeatable read）可能发生 幻读
- 序列化读（serializable）没有问题

### 一致性

这个特性其实比较特殊，这个应该是事务的最终追求。所以也可以说是上面的三种特性的实现共同实现了一致性。

# MySQL中的锁

从锁的类型来分，可以分为

- 共享锁 Share Lock
- 排它锁 Exclusive Lock

从锁粒度来分可以分为

- 全局所： 对整个数据库实例加锁
- 表锁 对整个表加锁
- 行锁 对记录所在的索引加锁
- 页面锁： 页面锁接触不多，我们可以暂时忽略

还有几个比较特殊的表级锁

- AUTO-INC Locks 自增主键用到的锁
- 共享意向锁
- 排他意向锁

行锁从类型又有可以分为

- 普通行锁 (record lock)
- 间隙锁 (gap lock)
- 邻间锁 (next-key lock)
- 插入意向锁 (insert intention lock)

下面我们稍微来分析一下

## 表锁

表锁，顾名思义直接锁定一张表，这个锁粒度比较大，但是优点是比较简单。

Memory、MyISAM 引擎都只支持表锁。

InnoDB在默认情况下不会使用普通的表锁，想要使用表锁的话需要使用`lock table`命令。

![](/img/locktable.png)

我们发现锁表之后，右边插入操作被阻塞住了。

接着我们使用下面命令查看一下锁状态，这个命令输出内容有很多，我们主要关注`TRANSACTION`部分

```SQL
show engine innodb status\G;
```
![](/img/transaction.png)

发现有一个表被锁定了。

![](/img/unlock.png)
当我们执行解锁命令，右面的操作就完成了。

表锁我们使用不多，所以不做过多了解，有兴趣的同学可以查看[表锁命令](https://blog.csdn.net/weixin_41282397/article/details/84791087)，进行了解。

### 意向锁和AUTO-INC锁

我们上面提到有2中特殊的表锁，分别是意向锁和自增锁。下面说一下他们的作用

#### 意向锁

意向锁的作用很简单，就是为了平衡表锁和行锁之间的冲突。我们想一下这个场景

- 一个事务T1在表A中对某些记录加了独占行锁。
- 另一个事务T2，想要对表A添加表锁。

这时候T2怎么判断表中又没其他事务加了行锁呢？遍历所有的记录是一个方式，但是这样效率太慢了，所以就提出了意向锁的概念。

- 如果想要共享行锁，那么就现在表上添加一个共享意向锁IS，然后在行记录的索引上添加S锁
- 如果想要独占行锁，那么就现在表上添加一个独占意向锁IX，然后在行记录的索引上添加X锁

有了这个机制，上面的事务T2，就不需要遍历就能知道当前这个表中有记录被添加了独占锁，下面来操作一下

![](/img/intentionLock.png)

- 首先在一个事务中使用`select * from user where id = 1 for update` 给表中的一条记录添加独占锁
- 然后在另一个事务中尝试锁表，

结果发现锁表的这个操作被阻塞了。我们来看一下锁状态

![](/img/lock1.png)
我们可以看到`user`表被添加了一个IX的意向锁。

![](/img/lock2.png)

- 接着我们提交事务
- 另一个事务中，获取表锁成功，说明在事务提交后，意向锁被释放了

接着我们测试一下共享行锁下的情况

![](/img/lock3.png)

- 首先我们使用 `select * from user where id = 1 lock in share mode;`给记录的索引添加共享行锁
- 接着分别使用 `lock table user read` 和 `lock table user write` 来分别尝试获取表级的读锁和写锁。

结果，在存在共享行锁的情况下，获取表级读锁可以成功，获取表级写锁会被阻塞。


#### AUTO-INC锁
